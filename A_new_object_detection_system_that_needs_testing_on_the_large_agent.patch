Index: scripts/ccm/lib/actr/blender_vision.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- scripts/ccm/lib/actr/blender_vision.py	(revision cf4e0898f3c10832cdcb0250baf8c5482b5ebafa)
+++ scripts/ccm/lib/actr/blender_vision.py	(revision )
@@ -65,7 +65,8 @@
         self._screenRight = numpy.arange(Decimal(0.0),Decimal(0.30),Decimal(0.002))
         #self._internalChunks.append(ccm.Model(isa='dial'))
 
-        self.function_map = {'scan':['scan_image_multi',{}]}
+        self.function_map = {'scan':['scan_image_multi',{}],
+                             'closest_scan':['closest_scan',{}]}
 
         #self._internalEnvironment = InternalEnvironment(self._b1)
         #self._internalEnvironment.doConvert(parent=self)
@@ -165,19 +166,58 @@
             print("keySize",keySize,depth,width)
             print(self._objects[openingsKey])
             for obj in self._objects[openingsKey]:
+
                 d1 = float(self._objects[openingsKey][obj][2])
                 d2 = float(self._objects[openingsKey][obj][3])
                 closer = 3
                 side = 'left'
                 if d1 <= d2:
                     closer = 2
-                if float(self._objects[openingsKey][obj][closer]) <= keySize * radius_multiplier:
-                    if float(self._objects[openingsKey][obj][closer -2]) < 0.50:
-                        side = 'right'
+                closer2 = 3
+
+                closest = None
+                closest = middleware.request(self.function_map['closest_scan'][0])[self.function_map['closest_scan'][0]]
+                print("checking closest")
+                for d in closest:
+                    if obj == d['hit']:
+                        print('angle',d['angle'],'distance',d['distance'],100 - math.degrees(math.acos(0.5/radius_multiplier)),keySize*radius_multiplier)
+                        if d['angle'] < 100 - math.degrees(math.acos(0.5/radius_multiplier)) and d['distance'] <= keySize * radius_multiplier:
+                            print("Added chunk second")
-                    self._internalChunks.append(ccm.Model(isa='obstacle',
-                                                          location=side,
-                                                          distance=repr(float(self._objects[openingsKey][obj][closer])),
-                                                          radians=repr(float(self._objects[openingsKey][obj][closer+2]))))
+                            self._internalChunks.append(ccm.Model(isa='obstacle',
+                                                                  location=side,
+                                                                  distance=repr(float(self._objects[openingsKey][obj][closer])),
+                                                                  radians=repr(float(self._objects[openingsKey][obj][closer+2]))))
+
+                # if float(self._objects[openingsKey][obj][4]) <= float(self._objects[openingsKey][obj][5]):
+                #     closer2 = 2
+                # if closer != closer2:
+                #     if self.sync:
+                #         raise Exception("This is not supported...")
+                #     else:
+                #         closest = middleware.request(self.function_map['closest_scan'][0])[self.function_map['closest_scan'][0]]
+                #
+                # if closest is None:
+                #     if float(self._objects[openingsKey][obj][closer]) <= keySize * radius_multiplier:
+                #         if float(self._objects[openingsKey][obj][closer -2]) < 0.50:
+                #             side = 'right'
+                #         print("abcdefg", self._objects[openingsKey][obj][closer+2],d1,d2,closer,obj)
+                #         if float(self._objects[openingsKey][obj][closer + 2]) <= 90 - math.degrees(math.acos(0.5/radius_multiplier)):
+                #             print("Added chunk first")
+                #             self._internalChunks.append(ccm.Model(isa='obstacle',
+                #                                                   location=side,
+                #                                                   distance=repr(float(self._objects[openingsKey][obj][closer])),
+                #                                                   radians=repr(float(self._objects[openingsKey][obj][closer+2]))))
+                # else:
+                #     print("checking closest")
+                #     for d in closest:
+                #         if obj == d['hit']:
+                #             print('angle',d['angle'],'distance',d['distance'])
+                #             if d['angle'] < 90 - math.degrees(math.acos(0.5/radius_multiplier)) and d['distance'] <= keySize * radius_multiplier:
+                #                 print("Added chunk second")
+                #                 self._internalChunks.append(ccm.Model(isa='obstacle',
+                #                                                       location=side,
+                #                                                       distance=repr(float(self._objects[openingsKey][obj][closer])),
+                #                                                       radians=repr(float(self._objects[openingsKey][obj][closer+2]))))
                     #obstacles.append([side,self._objects[openingsKey][obj][closer],self._objects[openingsKey][obj][closer + 2]])
                 # if float(self._objects[openingsKey][obj][2]) <= keySize * 3:
                 #     obstacles.append([self._objects[openingsKey][obj][2],self._objects[openingsKey][obj][4]])
Index: src/ACTR_3D/sensors/GeometricCamera.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/ACTR_3D/sensors/GeometricCamera.py	(revision cf4e0898f3c10832cdcb0250baf8c5482b5ebafa)
+++ src/ACTR_3D/sensors/GeometricCamera.py	(revision )
@@ -93,6 +93,7 @@
         morse.sensors.camera.Camera.__init__(self, obj, parent)
         self.visual_objects = {}
         self.robot_parent.func_map['scan_image_multi'] = self
+        self.robot_parent.func_map['closest_scan'] = self
         # Locate the Blender camera object associated with this sensor
         main_obj = self.bge_object
         for obj in main_obj.children:
@@ -471,7 +472,81 @@
             rowY+=1#a counter for the objects[hit][rowY]
         print(repr(time.time() - beginning) +  " TIME ASDFADFAD")
         return objects
+                               
+
+    def closest_scan(self,y=0.50,xstart=0.0,xstop=1.0,xyGrain=0.01,xyPrecision=0.002,depthGrain=0.01,minDepth=0.01,maxDepth=50,processes=8):
+        SmallGrain = Decimal(xyGrain).quantize(Decimal('.001'),rounding=ROUND_HALF_UP)
+        grain = float(SmallGrain)
+        xstart = xstart
+        xstop = xstop
+        results = []
+        closest = {'distance':10000,'hit':None,'angle':None}
+        results.append(closest)
+        x = xstart
+        y = y
+        while x < xstop:
+            print("X",x)
+            hit = repr(self.blender_cam.getScreenRay(x,y,2))
+            distance = self.distance_to_xy(x,y,minDepth,2,grainSize=depthGrain)
+            angle = self.getScreenVector(x,y)
+            entry = {'hit':hit,'distance':distance,'angle':angle}
+
+            if entry['distance'] <= closest['distance']:
+                results = [d for d in results if d['distance'] <= entry['distance']]
+                hits = 0
+                for d in results:
+                    if d['hit'] == entry['hit']:
+                        hits += 1
+                if not hits:
+                    results.append(entry)
+
+                #if entry['distance'] < closest['distance']:
+                #    results = [d for d in results if d['distance'] < entry['distance']]
+
+
+                #results.append(entry)
+                closest = entry
+            x+=grain
+        duplicateHits = []
+        removeHits = []
+
+        return results
+
+        # def worker(xstart,xstop,out_q):
+        # #return [123]
+        #     out_qu.put([])
+        #     x = xstart
+        #     while x < xstop:
+        #         hit = self.blender_cam.getScreenRay(x,y,2)
+        #         distance = self.distance_to_xy(x,y,minDepth,2,grainSize=depthGrain)
+        #         angle = self.getScreenVector(x,y)
+        #         entry = {'hit':hit,'distance':distance,'angle':angle}
+        #         if entry['distance'] <= closest['distance']:
+        #             results.append(entry)
+        #             closest['hit'] = entry['hit']
+        #             closest['angle'] = entry['angle']
+        #             closest['distance'] = entry['distance']
+        #         x+=grain
+        #
+        # out_q = mp.Queue()
+        # procs = []
+        #
+        # for i in range(processes):
+        #     p = mp.Process(target=worker,args=(i/processes,i/processes+(1/processes),out_q))
+        #     procs.append(p)
+        #     p.start()
+        #
+        # resultdict = {}
+        # for i in range(processes):
+        #     results.extend(out_q.get())
+        #
+        # for p in procs:
+        #     p.join()
+        # return results
+
+
+
-                               
+
     @service
     def scan_image_multi(self,ystart=0.0,ystop=1.0,xstart=0.0,xstop=1.0,xyGrain=0.01,xyPrecision=0.002,depthGrain=0.01,minDepth=0.01,maxDepth=50,processes=8):
         def worker(minY,maxY, out_q):
Index: scripts/Experiment0_NoMotorInteferenceWalking_nonLinear.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- scripts/Experiment0_NoMotorInteferenceWalking_nonLinear.py	(revision cf4e0898f3c10832cdcb0250baf8c5482b5ebafa)
+++ scripts/Experiment0_NoMotorInteferenceWalking_nonLinear.py	(revision )
@@ -1,4 +1,4 @@
-RadiusMultiplier=1.0
+RadiusMultiplier=1.2
 VisionMultiplier=1.0
 #Run with a morse environment already running.
 
